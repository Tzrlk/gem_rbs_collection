module RSpec
  module Core
    # Each ExampleGroup class and Example instance owns an instance of
    # Metadata, which is Hash extended to support lazy evaluation of values
    # associated with keys that may or may not be used by any example or group.
    #
    # In addition to metadata that is used internally, this also stores
    # user-supplied metadata, e.g.
    #
    #     RSpec.describe Something, :type => :ui do
    #       it "does something", :slow => true do
    #         # ...
    #       end
    #     end
    #
    # `:type => :ui` is stored in the Metadata owned by the example group, and
    # `:slow => true` is stored in the Metadata owned by the example. These can
    # then be used to select which examples are run using the `--tag` option on
    # the command line, or several methods on `Configuration` used to filter a
    # run (e.g. `filter_run_including`, `filter_run_excluding`, etc).
    #
    # @see Example#metadata
    # @see ExampleGroup.metadata
    # @see FilterManager
    # @see Configuration#filter_run_including
    # @see Configuration#filter_run_excluding
    module Metadata
      self.@relative_path_regex: untyped

      # Matches strings either at the beginning of the input or prefixed with a
      # whitespace, containing the current path, either postfixed with the
      # separator, or at the end of the string. Match groups are the character
      # before and the character after the string if any.
      #
      # http://rubular.com/r/fT0gmX6VJX
      # http://rubular.com/r/duOrD4i3wb
      # http://rubular.com/r/sbAMHFrOx1
      def self.relative_path_regex: () -> untyped

      # @api private
      #
      # @param line [String] current code line
      # @return [String] relative path to line
      def self.relative_path: (untyped line) -> untyped

      # @private
      # Iteratively walks up from the given metadata through all
      # example group ancestors, yielding each metadata hash along the way.
      def self.ascending: (untyped metadata) { (untyped) -> untyped } -> (nil | untyped)

      # @private
      # Returns an enumerator that iteratively walks up the given metadata through all
      # example group ancestors, yielding each metadata hash along the way.
      def self.ascend: (untyped metadata) -> untyped

      # @private
      # Used internally to build a hash from an args array.
      # Symbols are converted into hash keys with a value of `true`.
      # This is done to support simple tagging using a symbol, rather
      # than needing to do `:symbol => true`.
      def self.build_hash_from: (untyped args, ?bool warn_about_example_group_filtering) -> untyped

      # @private
      def self.deep_hash_dup: (untyped object) -> untyped

      # @private
      def self.id_from: (untyped metadata) -> ::String

      # @private
      def self.location_tuple_from: (untyped metadata) -> ::Array[untyped]

      # @private
      # Used internally to populate metadata hashes with computed keys
      # managed by RSpec.
      class HashPopulator
        @metadata: untyped

        @user_metadata: untyped

        @index_provider: untyped

        @description_args: untyped

        @block: untyped

        attr_reader metadata: untyped

        attr_reader user_metadata: untyped

        attr_reader description_args: untyped

        attr_reader block: untyped

        def initialize: (untyped metadata, untyped user_metadata, untyped index_provider, untyped description_args, untyped block) -> void

        def populate: () -> untyped

        private

        def populate_location_attributes: () -> untyped

        def file_path_and_line_number_from: (untyped backtrace) -> untyped

        def description_separator: (untyped parent_part, untyped child_part) -> ("" | " ")

        def build_description_from: (?untyped? parent_description, ?untyped? my_description) -> untyped

        def build_scoped_id_for: (untyped file_path) -> (untyped | ::String)

        def ensure_valid_user_keys: () -> untyped
      end

      # @private
      class ExampleHash < HashPopulator
        def self.create: (untyped group_metadata, untyped user_metadata, untyped index_provider, untyped description, untyped block) -> untyped

        private

        def described_class: () -> untyped

        def full_description: () -> untyped
      end

      # @private
      class ExampleGroupHash < HashPopulator
        def self.create: (untyped parent_group_metadata, untyped user_metadata, untyped example_group_index, *untyped args) { (?) -> untyped } -> untyped

        def self.hash_with_backwards_compatibility_default_proc: () -> untyped

        def self.backwards_compatibility_default_proc: () { (?) -> untyped } -> untyped

        private

        def described_class: () -> untyped

        def full_description: () -> untyped
      end

      # @private
      RESERVED_KEYS: ::Array[:description | :description_args | :described_class | :example_group | :parent_example_group | :execution_result | :last_run_status | :file_path | :absolute_file_path | :rerun_file_path | :full_description | :line_number | :location | :scoped_id | :block | :shared_group_inclusion_backtrace]
    end

    # Mixin that makes the including class imitate a hash for backwards
    # compatibility. The including class should use `attr_accessor` to
    # declare attributes.
    # @private
    module HashImitatable
      @extra_hash_attributes: untyped

      def self.included: (untyped klass) -> untyped

      def to_h: () -> untyped

      def []: (untyped key) -> untyped

      def []=: (untyped key, untyped value) -> untyped

      private

      def extra_hash_attributes: () -> untyped

      def directly_supports_attribute?: (untyped name) -> untyped

      def get_value: (untyped name) -> untyped

      def set_value: (untyped name, untyped value) -> untyped

      def hash_for_delegation: () -> untyped

      def issue_deprecation: (untyped _method_name, *untyped _args) -> nil

      # @private
      module ClassMethods
        @hash_attribute_names: untyped

        def hash_attribute_names: () -> untyped

        def attr_accessor: (*untyped names) -> untyped
      end
    end

    # @private
    # Together with the example group metadata hash default block,
    # provides backwards compatibility for the old `:example_group`
    # key. In RSpec 2.x, the computed keys of a group's metadata
    # were exposed from a nested subhash keyed by `[:example_group]`, and
    # then the parent group's metadata was exposed by sub-subhash
    # keyed by `[:example_group][:example_group]`.
    #
    # In RSpec 3, we reorganized this to that the computed keys are
    # exposed directly of the group metadata hash (no nesting), and
    # `:parent_example_group` returns the parent group's metadata.
    #
    # Maintaining backwards compatibility was difficult: we wanted
    # `:example_group` to return an object that:
    #
    #   * Exposes the top-level metadata keys that used to be nested
    #     under `:example_group`.
    #   * Supports mutation (rspec-rails, for example, assigns
    #     `metadata[:example_group][:described_class]` when you use
    #     anonymous controller specs) such that changes are written
    #     back to the top-level metadata hash.
    #   * Exposes the parent group metadata as
    #     `[:example_group][:example_group]`.
    class LegacyExampleGroupHash
      @metadata: untyped

      include HashImitatable

      def initialize: (untyped metadata) -> void

      def to_h: () -> untyped

      private

      def directly_supports_attribute?: (untyped name) -> untyped

      def get_value: (untyped name) -> untyped

      def set_value: (untyped name, untyped value) -> untyped
    end
  end
end
