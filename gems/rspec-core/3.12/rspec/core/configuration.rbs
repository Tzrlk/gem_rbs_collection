module RSpec
  module Core
    # Stores runtime configuration information.
    #
    # Configuration options are loaded from multiple files and joined together
    # with command-line switches and the `SPEC_OPTS` environment variable.
    #
    # Precedence order (where later entries overwrite earlier entries on
    # conflicts):
    #
    #   * Global (`$XDG_CONFIG_HOME/rspec/options`, or `~/.rspec` if it does
    #     not exist)
    #   * Project-specific (`./.rspec`)
    #   * Local (`./.rspec-local`)
    #   * Command-line options
    #   * `SPEC_OPTS`
    #
    # For example, an option set in the local file will override an option set
    # in your global file.
    #
    # The global, project-specific and local files can all be overridden with a
    # separate custom file using the --options command-line parameter.
    #
    # @example Standard settings
    #     RSpec.configure do |c|
    #       c.drb          = true
    #       c.drb_port     = 1234
    #       c.default_path = 'behavior'
    #     end
    #
    # @example Hooks
    #     RSpec.configure do |c|
    #       c.before(:suite)   { establish_connection }
    #       c.before(:example) { log_in_as :authorized }
    #       c.around(:example) { |ex| Database.transaction(&ex) }
    #     end
    #
    # @see RSpec.configure
    # @see Hooks
    class Configuration
      @default_path: untyped

      @deprecation_stream: untyped

      @example_status_persistence_file_path: untyped

      @fail_fast: untyped

      @output_stream: untyped

      @shared_context_metadata_behavior: untyped

      @bisect_runner: untyped

      # rubocop:disable Style/GlobalVars
      @start_time: untyped

      # rubocop:enable Style/GlobalVars
      @expectation_frameworks: untyped

      @include_modules: untyped

      @extend_modules: untyped

      @prepend_modules: untyped

      @bisect_runner_class: untyped

      @before_suite_hooks: untyped

      @after_suite_hooks: untyped

      @mock_framework: untyped

      @files_or_directories_to_run: untyped

      @loaded_spec_files: untyped

      @color: untyped

      @color_mode: untyped

      @pattern: untyped

      @exclude_pattern: untyped

      @failure_exit_code: untyped

      @error_exit_code: untyped

      @fail_if_no_examples: untyped

      @spec_files_loaded: untyped

      @backtrace_formatter: untyped

      @project_source_dirs: untyped

      @reporter: untyped

      @reporter_buffer: untyped

      @filter_manager: untyped

      @static_config_filter_manager: untyped

      @ordering_manager: untyped

      @preferred_options: untyped

      @failure_color: untyped

      @success_color: untyped

      @pending_color: untyped

      @default_color: untyped

      @fixed_color: untyped

      @detail_color: untyped

      @profile_examples: untyped

      @requires: untyped

      @libs: untyped

      @derived_metadata_blocks: untyped

      @threadsafe: untyped

      @max_displayed_failure_line_count: untyped

      @world: untyped

      @formatter_loader: untyped

      @output_wrapper: untyped

      @files_to_run: untyped

      @last_run_statuses: untyped

      @spec_files_with_failures: untyped

      @format_docstrings_block: untyped

      @hooks: untyped

      @on_example_group_definition_callbacks: untyped

      include RSpec::Core::Hooks

      # Module that holds `attr_reader` declarations. It's in a separate
      # module to allow us to override those methods and use `super`.
      # @private
      Readers: untyped

      include Readers

      # @private
      class MustBeConfiguredBeforeExampleGroupsError < StandardError
      end

      # @private
      def self.define_reader: (untyped name) -> untyped

      # @private
      def self.define_alias: (untyped name, untyped alias_name) -> untyped

      # @private
      def self.define_predicate: (untyped name) -> untyped

      # @private
      #
      # Invoked by the `add_setting` instance method. Use that method on a
      # `Configuration` instance rather than this class method.
      def self.add_setting: (untyped name, ?::Hash[untyped, untyped] opts) -> untyped

      # @private
      #
      # As `add_setting` but only add the reader.
      def self.add_read_only_setting: (untyped name, ?::Hash[untyped, untyped] opts) -> untyped

      def default_path=: (untyped path) -> untyped

      # Indicates if the DSL has been exposed off of modules and `main`.
      # Default: true
      # @return [Boolean]
      def expose_dsl_globally?: () -> untyped

      # Use this to expose the core RSpec DSL via `Module` and the `main`
      # object. It will be set automatically but you can override it to
      # remove the DSL.
      # Default: true
      def expose_dsl_globally=: (untyped value) -> untyped

      # Determines where deprecation warnings are printed.
      # @param value [IO, String] IO to write to or filename to write to
      def deprecation_stream=: (untyped value) -> untyped

      # Sets the file path to use for persisting example statuses. Necessary for the
      # `--only-failures` and `--next-failure` CLI options.
      def example_status_persistence_file_path=: (untyped value) -> untyped

      alias only_failures? only_failures

      # @private
      def only_failures_but_not_configured?: () -> untyped

      # @see fail_fast
      def fail_fast=: (untyped value) -> untyped

      # Set the output stream for reporter.
      # @attr value [IO, String] IO to write to or filename to write to, defaults to $stdout
      def output_stream=: (untyped value) -> untyped

      # Set pattern to match files to load.
      # @attr value [String] the filename pattern to filter spec files by
      def pattern=: (untyped value) -> untyped

      # Set pattern to match files to exclude.
      # @attr value [String] the filename pattern to exclude spec files by
      def exclude_pattern=: (untyped value) -> untyped

      # @macro add_setting
      # Report the times for the slowest examples (default: `false`).
      # Use this to specify the number of examples to include in the profile.
      # @return [Boolean]
      attr_writer profile_examples: untyped

      # @deprecated This config option was added in RSpec 2 to pave the way
      #   for this being the default behavior in RSpec 3. Now this option is
      #   a no-op.
      def treat_symbols_as_metadata_keys_with_true_values=: (untyped _value) -> untyped

      # @see shared_context_metadata_behavior
      def shared_context_metadata_behavior=: (untyped value) -> untyped

      # Determines which bisect runner implementation gets used to run subsets
      # of the suite during a bisection. Your choices are:
      #
      #   - `:shell`: Performs a spec run by shelling out, booting RSpec and your
      #     application environment each time. This runner is the most widely
      #     compatible runner, but is not as fast. On platforms that do not
      #     support forking, this is the default.
      #   - `:fork`: Pre-boots RSpec and your application environment in a parent
      #     process, and then forks a child process for each spec run. This runner
      #     tends to be significantly faster than the `:shell` runner but cannot
      #     be used in some situations. On platforms that support forking, this
      #     is the default. If you use this runner, you should ensure that all
      #     of your one-time setup logic goes in a `before(:suite)` hook instead
      #     of getting run at the top-level of a file loaded by `--require`.
      #
      # @note This option will only be used by `--bisect` if you set it in a file
      #   loaded via `--require`.
      #
      # @return [Symbol]
      attr_reader bisect_runner: untyped

      def bisect_runner=: (untyped value) -> untyped

      # @private
      attr_writer files_to_run: untyped

      # @private
      attr_accessor filter_manager: untyped

      # @private
      attr_accessor world: untyped

      # @private
      attr_accessor static_config_filter_manager: untyped

      # @private
      attr_reader backtrace_formatter: untyped

      # @private
      attr_reader ordering_manager: untyped

      # @private
      attr_reader loaded_spec_files: untyped

      # Build an object to store runtime configuration options and set defaults
      def initialize: () -> void

      # @private
      #
      # Used to set higher priority option values from the command line.
      def force: (untyped hash) -> (nil | untyped)

      # @private
      def reset: () -> untyped

      # @private
      def reset_reporter: () -> untyped

      # @private
      def reset_filters: () -> untyped

      # @overload add_setting(name)
      # @overload add_setting(name, opts)
      # @option opts [Symbol] :default
      #
      #   Set a default value for the generated getter and predicate methods:
      #
      #       add_setting(:foo, :default => "default value")
      #
      # @option opts [Symbol] :alias_with
      #
      #   Use `:alias_with` to alias the setter, getter, and predicate to
      #   another name, or names:
      #
      #       add_setting(:foo, :alias_with => :bar)
      #       add_setting(:foo, :alias_with => [:bar, :baz])
      #
      # Adds a custom setting to the RSpec.configuration object.
      #
      #     RSpec.configuration.add_setting :foo
      #
      # Used internally and by extension frameworks like rspec-rails, so they
      # can add config settings that are domain specific. For example:
      #
      #     RSpec.configure do |c|
      #       c.add_setting :use_transactional_fixtures,
      #         :default => true,
      #         :alias_with => :use_transactional_examples
      #     end
      #
      # `add_setting` creates three methods on the configuration object, a
      # setter, a getter, and a predicate:
      #
      #     RSpec.configuration.foo=(value)
      #     RSpec.configuration.foo
      #     RSpec.configuration.foo? # Returns true if foo returns anything but nil or false.
      def add_setting: (untyped name, ?::Hash[untyped, untyped] opts) -> untyped

      # Returns the configured mock framework adapter module.
      # @return [Symbol]
      def mock_framework: () -> untyped

      # Delegates to mock_framework=(framework).
      def mock_framework=: (untyped framework) -> untyped

      # Regexps used to exclude lines from backtraces.
      #
      # Excludes lines from ruby (and jruby) source, installed gems, anything
      # in any "bin" directory, and any of the RSpec libs (outside gem
      # installs) by default.
      #
      # You can modify the list via the getter, or replace it with the setter.
      #
      # To override this behaviour and display a full backtrace, use
      # `--backtrace` on the command line, in a `.rspec` file, or in the
      # `rspec_options` attribute of RSpec's rake task.
      # @return [Array<Regexp>]
      def backtrace_exclusion_patterns: () -> untyped

      # Set regular expressions used to exclude lines in backtrace.
      # @param patterns [Array<Regexp>] set backtrace_formatter exclusion_patterns
      def backtrace_exclusion_patterns=: (untyped patterns) -> untyped

      # Regexps used to include lines in backtraces.
      #
      # Defaults to [Regexp.new Dir.getwd].
      #
      # Lines that match an exclusion _and_ an inclusion pattern
      # will be included.
      #
      # You can modify the list via the getter, or replace it with the setter.
      # @return [Array<Regexp>]
      def backtrace_inclusion_patterns: () -> untyped

      # Set regular expressions used to include lines in backtrace.
      # @attr patterns [Array<Regexp>] set backtrace_formatter inclusion_patterns
      def backtrace_inclusion_patterns=: (untyped patterns) -> untyped

      # Adds {#backtrace_exclusion_patterns} that will filter lines from
      # the named gems from backtraces.
      #
      # @param gem_names [Array<String>] Names of the gems to filter
      #
      # @example
      #   RSpec.configure do |config|
      #     config.filter_gems_from_backtrace "rack", "rake"
      #   end
      #
      # @note The patterns this adds will match the named gems in their common
      #   locations (e.g. system gems, vendored with bundler, installed as a
      #   :git dependency with bundler, etc) but is not guaranteed to work for
      #   all possible gem locations. For example, if you have the gem source
      #   in a directory with a completely unrelated name, and use bundler's
      #   :path option, this will not filter it.
      def filter_gems_from_backtrace: (*untyped gem_names) -> untyped

      # @private
      MOCKING_ADAPTERS: { rspec: :RSpec, flexmock: :Flexmock, rr: :RR, mocha: :Mocha, nothing: :Null }

      # Sets the mock framework adapter module.
      #
      # `framework` can be a Symbol or a Module.
      #
      # Given any of `:rspec`, `:mocha`, `:flexmock`, or `:rr`, configures the
      # named framework.
      #
      # Given `:nothing`, configures no framework. Use this if you don't use
      # any mocking framework to save a little bit of overhead.
      #
      # Given a Module, includes that module in every example group. The module
      # should adhere to RSpec's mock framework adapter API:
      #
      #     setup_mocks_for_rspec
      #       - called before each example
      #
      #     verify_mocks_for_rspec
      #       - called after each example if the example hasn't yet failed.
      #         Framework should raise an exception when expectations fail
      #
      #     teardown_mocks_for_rspec
      #       - called after verify_mocks_for_rspec (even if there are errors)
      #
      # If the module responds to `configuration` and `mock_with` receives a
      # block, it will yield the configuration object to the block e.g.
      #
      #     config.mock_with OtherMockFrameworkAdapter do |mod_config|
      #       mod_config.custom_setting = true
      #     end
      def mock_with: (untyped framework) ?{ (untyped) -> untyped } -> untyped

      # Returns the configured expectation framework adapter module(s)
      def expectation_frameworks: () -> untyped

      # Delegates to expect_with(framework).
      def expectation_framework=: (untyped framework) -> untyped

      # Sets the expectation framework module(s) to be included in each example
      # group.
      #
      # `frameworks` can be `:rspec`, `:test_unit`, `:minitest`, a custom
      # module, or any combination thereof:
      #
      #     config.expect_with :rspec
      #     config.expect_with :test_unit
      #     config.expect_with :minitest
      #     config.expect_with :rspec, :minitest
      #     config.expect_with OtherExpectationFramework
      #
      # RSpec will translate `:rspec`, `:minitest`, and `:test_unit` into the
      # appropriate modules.
      #
      # ## Configuration
      #
      # If the module responds to `configuration`, `expect_with` will
      # yield the `configuration` object if given a block:
      #
      #     config.expect_with OtherExpectationFramework do |custom_config|
      #       custom_config.custom_setting = true
      #     end
      def expect_with: (*untyped frameworks) ?{ (untyped) -> untyped } -> untyped

      # Check if full backtrace is enabled.
      # @return [Boolean] is full backtrace enabled
      def full_backtrace?: () -> untyped

      # Toggle full backtrace.
      # @attr true_or_false [Boolean] toggle full backtrace display
      def full_backtrace=: (untyped true_or_false) -> untyped

      # Enables color output if the output is a TTY.  As of RSpec 3.6, this is
      # the default behavior and this option is retained only for backwards
      # compatibility.
      #
      # @deprecated No longer recommended because of complex behavior. Instead,
      #   rely on the fact that TTYs will display color by default, or set
      #   {#color_mode} to :on to display color on a non-TTY output.
      # @see color_mode
      # @see color_enabled?
      # @return [Boolean]
      def color: () -> untyped

      # The mode for determining whether to display output in color. One of:
      #
      # - :automatic - the output will be in color if the output is a TTY (the
      #   default)
      # - :on - the output will be in color, whether or not the output is a TTY
      # - :off - the output will not be in color
      #
      # @see color_enabled?
      # @return [Boolean]
      def color_mode: () -> untyped

      # Check if color is enabled for a particular output.
      # @param output [IO] an output stream to use, defaults to the current
      #        `output_stream`
      # @return [Boolean]
      def color_enabled?: (?untyped output) -> untyped

      # Set the color mode.
      attr_writer color_mode: untyped

      # Toggle output color.
      #
      # @deprecated No longer recommended because of complex behavior. Instead,
      #   rely on the fact that TTYs will display color by default, or set
      #   {:color_mode} to :on to display color on a non-TTY output.
      attr_writer color: untyped

      # @private
      def libs=: (untyped libs) -> untyped

      # Run examples matching on `description` in all files to run.
      # @param description [String, Regexp] the pattern to filter on
      def full_description=: (untyped description) -> untyped

      # @return [Array] full description filter
      def full_description: () -> untyped

      # @overload add_formatter(formatter)
      # @overload add_formatter(formatter, output)
      #
      # @param formatter [Class, String, Object] formatter to use. Can be any of the
      #   string values supported from the CLI (`p`/`progress`,
      #   `d`/`doc`/`documentation`, `h`/`html`, or `j`/`json`), any
      #   class that implements the formatter protocol and has registered
      #   itself with RSpec as a formatter, or a formatter instance.
      # @param output [String, IO] where the formatter will write its output.
      #   Can be an IO object or a string path to a file. If not provided,
      #   the configured `output_stream` (`$stdout`, by default) will be used.
      #
      # Adds a formatter to the set RSpec will use for this run.
      #
      # @see RSpec::Core::Formatters::Protocol
      def add_formatter: (untyped formatter, ?untyped output) -> untyped

      alias formatter= add_formatter

      # The formatter that will be used if no formatter has been set.
      # Defaults to 'progress'.
      def default_formatter: () -> untyped

      # Sets a fallback formatter to use if none other has been set.
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.default_formatter = 'doc'
      #   end
      def default_formatter=: (untyped value) -> untyped

      # Returns a duplicate of the formatters currently loaded in
      # the `FormatterLoader` for introspection.
      #
      # Note as this is a duplicate, any mutations will be disregarded.
      #
      # @return [Array] the formatters currently loaded
      def formatters: () -> untyped

      # @private
      def formatter_loader: () -> untyped

      # @private
      #
      # This buffer is used to capture all messages sent to the reporter during
      # reporter initialization. It can then replay those messages after the
      # formatter is correctly initialized. Otherwise, deprecation warnings
      # during formatter initialization can cause an infinite loop.
      class DeprecationReporterBuffer
        @calls: untyped

        def initialize: () -> void

        def deprecation: (*untyped args) -> untyped

        def play_onto: (untyped reporter) -> untyped
      end

      # @return [RSpec::Core::Reporter] the currently configured reporter
      def reporter: () -> untyped

      # @api private
      #
      # Defaults `profile_examples` to 10 examples when `@profile_examples` is
      # `true`.
      def profile_examples: () -> untyped

      # @private
      def files_or_directories_to_run=: (*untyped files) -> untyped

      # The spec files RSpec will run.
      # @return [Array] specified files about to run
      def files_to_run: () -> untyped

      # @private
      def last_run_statuses: () -> untyped

      # @private
      UNKNOWN_STATUS: "unknown"

      # @private
      FAILED_STATUS: "failed"

      # @private
      PASSED_STATUS: "passed"

      # @private
      PENDING_STATUS: "pending"

      # @private
      VALID_STATUSES: ::Array[untyped]

      # @private
      def spec_files_with_failures: () -> untyped

      # Creates a method that delegates to `example` including the submitted
      # `args`. Used internally to add variants of `example` like `pending`:
      # @param name [String] example name alias
      # @param args [Array<Symbol>, Hash] metadata for the generated example
      #
      # @note The specific example alias below (`pending`) is already
      #   defined for you.
      # @note Use with caution. This extends the language used in your
      #   specs, but does not add any additional documentation. We use this
      #   in RSpec to define methods like `focus` and `xit`, but we also add
      #   docs for those methods.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.alias_example_to :pending, :pending => true
      #   end
      #
      #   # This lets you do this:
      #
      #   RSpec.describe Thing do
      #     pending "does something" do
      #       thing = Thing.new
      #     end
      #   end
      #
      #   # ... which is the equivalent of
      #
      #   RSpec.describe Thing do
      #     it "does something", :pending => true do
      #       thing = Thing.new
      #     end
      #   end
      def alias_example_to: (untyped name, *untyped args) -> untyped

      # Creates a method that defines an example group with the provided
      # metadata. Can be used to define example group/metadata shortcuts.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.alias_example_group_to :describe_model, :type => :model
      #   end
      #
      #   shared_context_for "model tests", :type => :model do
      #     # define common model test helper methods, `let` declarations, etc
      #   end
      #
      #   # This lets you do this:
      #
      #   RSpec.describe_model User do
      #   end
      #
      #   # ... which is the equivalent of
      #
      #   RSpec.describe User, :type => :model do
      #   end
      #
      # @note The defined aliased will also be added to the top level
      #       (e.g. `main` and from within modules) if
      #       `expose_dsl_globally` is set to true.
      # @see #alias_example_to
      # @see #expose_dsl_globally=
      def alias_example_group_to: (untyped new_name, *untyped args) -> untyped

      # Define an alias for it_should_behave_like that allows different
      # language (like "it_has_behavior" or "it_behaves_like") to be
      # employed when including shared examples.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.alias_it_behaves_like_to(:it_has_behavior, 'has behavior:')
      #   end
      #
      #   # allows the user to include a shared example group like:
      #
      #   RSpec.describe Entity do
      #     it_has_behavior 'sortability' do
      #       let(:sortable) { Entity.new }
      #     end
      #   end
      #
      #   # which is reported in the output as:
      #   # Entity
      #   #   has behavior: sortability
      #   #     ...sortability examples here
      #
      # @note Use with caution. This extends the language used in your
      #   specs, but does not add any additional documentation. We use this
      #   in RSpec to define `it_should_behave_like` (for backward
      #   compatibility), but we also add docs for that method.
      def alias_it_behaves_like_to: (untyped new_name, ?::String report_label) -> untyped

      alias alias_it_should_behave_like_to alias_it_behaves_like_to

      # Adds key/value pairs to the `inclusion_filter`. If `args`
      # includes any symbols that are not part of the hash, each symbol
      # is treated as a key in the hash with the value `true`.
      #
      # ### Note
      #
      # Filters set using this method can be overridden from the command line
      # or config files (e.g. `.rspec`).
      #
      # @example
      #     # Given this declaration.
      #     describe "something", :foo => 'bar' do
      #       # ...
      #     end
      #
      #     # Any of the following will include that group.
      #     config.filter_run_including :foo => 'bar'
      #     config.filter_run_including :foo => /^ba/
      #     config.filter_run_including :foo => lambda {|v| v == 'bar'}
      #     config.filter_run_including :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     # Given a proc with an arity of 1, the lambda is passed the value
      #     # related to the key, e.g.
      #     config.filter_run_including :foo => lambda {|v| v == 'bar'}
      #
      #     # Given a proc with an arity of 2, the lambda is passed the value
      #     # related to the key, and the metadata itself e.g.
      #     config.filter_run_including :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     filter_run_including :foo # same as filter_run_including :foo => true
      def filter_run_including: (*untyped args) -> untyped

      alias filter_run filter_run_including

      # Applies the provided filter only if any of examples match, in constrast
      # to {#filter_run}, which always applies even if no examples match, in
      # which case no examples will be run. This allows you to leave configured
      # filters in place that are intended only for temporary use. The most common
      # example is focus filtering: `config.filter_run_when_matching :focus`.
      # With that configured, you can temporarily focus an example or group
      # by tagging it with `:focus` metadata, or prefixing it with an `f`
      # (as in `fdescribe`, `fcontext` and `fit`) since those are aliases for
      # `describe`/`context`/`it` with `:focus` metadata.
      def filter_run_when_matching: (*untyped args) -> untyped

      # Clears and reassigns the `inclusion_filter`. Set to `nil` if you don't
      # want any inclusion filter at all.
      #
      # ### Warning
      #
      # This overrides any inclusion filters/tags set on the command line or in
      # configuration files.
      def inclusion_filter=: (untyped filter) -> untyped

      alias filter= inclusion_filter=

      # Returns the `inclusion_filter`. If none has been set, returns an empty
      # hash.
      def inclusion_filter: () -> untyped

      alias filter inclusion_filter

      # Adds key/value pairs to the `exclusion_filter`. If `args`
      # includes any symbols that are not part of the hash, each symbol
      # is treated as a key in the hash with the value `true`.
      #
      # ### Note
      #
      # Filters set using this method can be overridden from the command line
      # or config files (e.g. `.rspec`).
      #
      # @example
      #     # Given this declaration.
      #     describe "something", :foo => 'bar' do
      #       # ...
      #     end
      #
      #     # Any of the following will exclude that group.
      #     config.filter_run_excluding :foo => 'bar'
      #     config.filter_run_excluding :foo => /^ba/
      #     config.filter_run_excluding :foo => lambda {|v| v == 'bar'}
      #     config.filter_run_excluding :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     # Given a proc with an arity of 1, the lambda is passed the value
      #     # related to the key, e.g.
      #     config.filter_run_excluding :foo => lambda {|v| v == 'bar'}
      #
      #     # Given a proc with an arity of 2, the lambda is passed the value
      #     # related to the key, and the metadata itself e.g.
      #     config.filter_run_excluding :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     filter_run_excluding :foo # same as filter_run_excluding :foo => true
      def filter_run_excluding: (*untyped args) -> untyped

      # Clears and reassigns the `exclusion_filter`. Set to `nil` if you don't
      # want any exclusion filter at all.
      #
      # ### Warning
      #
      # This overrides any exclusion filters/tags set on the command line or in
      # configuration files.
      def exclusion_filter=: (untyped filter) -> untyped

      # Returns the `exclusion_filter`. If none has been set, returns an empty
      # hash.
      def exclusion_filter: () -> untyped

      # Tells RSpec to include `mod` in example groups. Methods defined in
      # `mod` are exposed to examples (not example groups). Use `filters` to
      # constrain the groups or examples in which to include the module.
      #
      # @example
      #
      #     module AuthenticationHelpers
      #       def login_as(user)
      #         # ...
      #       end
      #     end
      #
      #     module PreferencesHelpers
      #       def preferences(user, preferences = {})
      #         # ...
      #       end
      #     end
      #
      #     module UserHelpers
      #       def users(username)
      #         # ...
      #       end
      #     end
      #
      #     RSpec.configure do |config|
      #       config.include(UserHelpers) # included in all groups
      #
      #       # included in examples with `:preferences` metadata
      #       config.include(PreferenceHelpers, :preferences)
      #
      #       # included in examples with `:type => :request` metadata
      #       config.include(AuthenticationHelpers, :type => :request)
      #     end
      #
      #     describe "edit profile", :preferences, :type => :request do
      #       it "can be viewed by owning user" do
      #         login_as preferences(users(:jdoe), :lang => 'es')
      #         get "/profiles/jdoe"
      #         assert_select ".username", :text => 'jdoe'
      #       end
      #     end
      #
      # @note Filtered module inclusions can also be applied to
      #   individual examples that have matching metadata. Just like
      #   Ruby's object model is that every object has a singleton class
      #   which has only a single instance, RSpec's model is that every
      #   example has a singleton example group containing just the one
      #   example.
      #
      # @see #include_context
      # @see #extend
      # @see #prepend
      def include: (untyped mod, *untyped filters) -> untyped

      # Tells RSpec to include the named shared example group in example groups.
      # Use `filters` to constrain the groups or examples in which to include
      # the example group.
      #
      # @example
      #
      #     RSpec.shared_context "example admin user" do
      #       let(:admin_user) { create_user(:admin) }
      #     end
      #
      #     RSpec.shared_context "example guest user" do
      #       let(:guest_user) { create_user(:guest) }
      #     end
      #
      #     RSpec.configure do |config|
      #       config.include_context "example guest user", :type => :request
      #       config.include_context "example admin user", :admin, :type => :request
      #     end
      #
      #     RSpec.describe "The admin page", :type => :request do
      #       it "can be viewed by admins", :admin do
      #         login_with admin_user
      #         get "/admin"
      #         expect(response).to be_ok
      #       end
      #
      #       it "cannot be viewed by guests" do
      #         login_with guest_user
      #         get "/admin"
      #         expect(response).to be_forbidden
      #       end
      #     end
      #
      # @note Filtered context inclusions can also be applied to
      #   individual examples that have matching metadata. Just like
      #   Ruby's object model is that every object has a singleton class
      #   which has only a single instance, RSpec's model is that every
      #   example has a singleton example group containing just the one
      #   example.
      #
      # @see #include
      def include_context: (untyped shared_group_name, *untyped filters) -> untyped

      # Tells RSpec to extend example groups with `mod`. Methods defined in
      # `mod` are exposed to example groups (not examples). Use `filters` to
      # constrain the groups to extend.
      #
      # Similar to `include`, but behavior is added to example groups, which
      # are classes, rather than the examples, which are instances of those
      # classes.
      #
      # @example
      #
      #     module UiHelpers
      #       def run_in_browser
      #         # ...
      #       end
      #     end
      #
      #     module PermissionHelpers
      #       def define_permissions
      #         # ...
      #       end
      #     end
      #
      #     RSpec.configure do |config|
      #       config.extend(UiHelpers, :type => :request)
      #       config.extend(PermissionHelpers, :with_permissions, :type => :request)
      #     end
      #
      #     describe "edit profile", :with_permissions, :type => :request do
      #       run_in_browser
      #       define_permissions
      #
      #       it "does stuff in the client" do
      #         # ...
      #       end
      #     end
      #
      # @see #include
      # @see #prepend
      def extend: (untyped mod, *untyped filters) -> untyped

      # Tells RSpec to prepend example groups with `mod`. Methods defined in
      # `mod` are exposed to examples (not example groups). Use `filters` to
      # constrain the groups in which to prepend the module.
      #
      # Similar to `include`, but module is included before the example group's class
      # in the ancestor chain.
      #
      # @example
      #
      #     module OverrideMod
      #       def override_me
      #         "overridden"
      #       end
      #     end
      #
      #     RSpec.configure do |config|
      #       config.prepend(OverrideMod, :method => :prepend)
      #     end
      #
      #     describe "overriding example's class", :method => :prepend do
      #       it "finds the user" do
      #         self.class.class_eval do
      #           def override_me
      #           end
      #         end
      #         override_me # => "overridden"
      #         # ...
      #       end
      #     end
      #
      # @see #include
      # @see #extend
      def prepend: (untyped mod, *untyped filters) -> untyped

      # @private
      #
      # Used internally to extend a group with modules using `include`, `prepend` and/or
      # `extend`.
      def configure_group: (untyped group) -> untyped

      # @private
      #
      # Used internally to extend the singleton class of a single example's
      # example group instance with modules using `include` and/or `extend`.
      def configure_example: (untyped example, untyped example_hooks) -> untyped

      # @private
      def requires=: (untyped paths) -> untyped

      # @private
      def in_project_source_dir_regex: () -> untyped

      # @private
      def configure_mock_framework: () -> untyped

      # @private
      def configure_expectation_framework: () -> untyped

      # @private
      def load_spec_files: () -> untyped

      # @private
      DEFAULT_FORMATTER: untyped

      # Formats the docstring output using the block provided.
      #
      # @example
      #   # This will strip the descriptions of both examples and example
      #   # groups.
      #   RSpec.configure do |config|
      #     config.format_docstrings { |s| s.strip }
      #   end
      def format_docstrings: () ?{ (?) -> untyped } -> untyped

      # @private
      def format_docstrings_block: () -> untyped

      # @private
      def self.delegate_to_ordering_manager: (*untyped methods) -> untyped

      # Set Ruby warnings on or off.
      def warnings=: (untyped value) -> untyped

      # @return [Boolean] Whether or not ruby warnings are enabled.
      def warnings?: () -> untyped

      # @private
      RAISE_ERROR_WARNING_NOTIFIER: untyped

      # Turns warnings into errors. This can be useful when
      # you want RSpec to run in a 'strict' no warning situation.
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.raise_on_warning = true
      #   end
      def raise_on_warning=: (untyped value) -> untyped

      # Exposes the current running example via the named
      # helper method. RSpec 2.x exposed this via `example`,
      # but in RSpec 3.0, the example is instead exposed via
      # an arg yielded to `it`, `before`, `let`, etc. However,
      # some extension gems (such as Capybara) depend on the
      # RSpec 2.x's `example` method, so this config option
      # can be used to maintain compatibility.
      #
      # @param method_name [Symbol] the name of the helper method
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.expose_current_running_example_as :example
      #   end
      #
      #   RSpec.describe MyClass do
      #     before do
      #       # `example` can be used here because of the above config.
      #       do_something if example.metadata[:type] == "foo"
      #     end
      #   end
      def expose_current_running_example_as: (untyped method_name) -> untyped

      include ExposeCurrentExample

      # @private
      module ExposeCurrentExample
      end

      # Turns deprecation warnings into errors, in order to surface
      # the full backtrace of the call site. This can be useful when
      # you need more context to address a deprecation than the
      # single-line call site normally provided.
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.raise_errors_for_deprecations!
      #   end
      def raise_errors_for_deprecations!: () -> untyped

      # Enables zero monkey patching mode for RSpec. It removes monkey
      # patching of the top-level DSL methods (`describe`,
      # `shared_examples_for`, etc) onto `main` and `Module`, instead
      # requiring you to prefix these methods with `RSpec.`. It enables
      # expect-only syntax for rspec-mocks and rspec-expectations. It
      # simply disables monkey patching on whatever pieces of RSpec
      # the user is using.
      #
      # @note It configures rspec-mocks and rspec-expectations only
      #   if the user is using those (either explicitly or implicitly
      #   by not setting `mock_with` or `expect_with` to anything else).
      #
      # @note If the user uses this options with `mock_with :mocha`
      #   (or similar) they will still have monkey patching active
      #   in their test environment from mocha.
      #
      # @example
      #
      #   # It disables all monkey patching.
      #   RSpec.configure do |config|
      #     config.disable_monkey_patching!
      #   end
      #
      #   # Is an equivalent to
      #   RSpec.configure do |config|
      #     config.expose_dsl_globally = false
      #
      #     config.mock_with :rspec do |mocks|
      #       mocks.syntax = :expect
      #       mocks.patch_marshal_to_support_partial_doubles = false
      #     end
      #
      #     config.expect_with :rspec do |expectations|
      #       expectations.syntax = :expect
      #     end
      #   end
      def disable_monkey_patching!: () -> untyped

      # @private
      attr_accessor disable_monkey_patching: untyped

      # Defines a callback that can assign derived metadata values.
      #
      # @param filters [Array<Symbol>, Hash] metadata filters that determine
      #   which example or group metadata hashes the callback will be triggered
      #   for. If none are given, the callback will be run against the metadata
      #   hashes of all groups and examples.
      # @yieldparam metadata [Hash] original metadata hash from an example or
      #   group. Mutate this in your block as needed.
      #
      # @example
      #   RSpec.configure do |config|
      #     # Tag all groups and examples in the spec/unit directory with
      #     # :type => :unit
      #     config.define_derived_metadata(:file_path => %r{/spec/unit/}) do |metadata|
      #       metadata[:type] = :unit
      #     end
      #   end
      def define_derived_metadata: (*untyped filters) { (?) -> untyped } -> untyped

      # Defines a callback that runs after the first example with matching
      # metadata is defined. If no examples are defined with matching metadata,
      # it will not get called at all.
      #
      # This can be used to ensure some setup is performed (such as bootstrapping
      # a DB or loading a specific file that adds significantly to the boot time)
      # if needed (as indicated by the presence of an example with matching metadata)
      # but avoided otherwise.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.when_first_matching_example_defined(:db) do
      #       # Load a support file that does some heavyweight setup,
      #       # including bootstrapping the DB, but only if we have loaded
      #       # any examples tagged with `:db`.
      #       require 'support/db'
      #     end
      #   end
      def when_first_matching_example_defined: (*untyped filters) { () -> untyped } -> (nil | untyped)

      # @private
      def apply_derived_metadata_to: (untyped metadata) -> (nil | untyped)

      # Defines a `before` hook. See {Hooks#before} for full docs.
      #
      # This method differs from {Hooks#before} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once before
      # the first example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #prepend_before
      # @see #after
      # @see #append_after
      def before: (?untyped? scope, *untyped meta) { (?) -> untyped } -> untyped

      alias append_before before

      # Adds `block` to the start of the list of `before` blocks in the same
      # scope (`:example`, `:context`, or `:suite`), in contrast to {#before},
      # which adds the hook to the end of the list.
      #
      # See {Hooks#before} for full `before` hook docs.
      #
      # This method differs from {Hooks#prepend_before} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once before
      # the first example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #before
      # @see #after
      # @see #append_after
      def prepend_before: (?untyped? scope, *untyped meta) { (?) -> untyped } -> untyped

      # Defines a `after` hook. See {Hooks#after} for full docs.
      #
      # This method differs from {Hooks#after} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once after
      # the last example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #append_after
      # @see #before
      # @see #prepend_before
      def after: (?untyped? scope, *untyped meta) { (?) -> untyped } -> untyped

      alias prepend_after after

      # Adds `block` to the end of the list of `after` blocks in the same
      # scope (`:example`, `:context`, or `:suite`), in contrast to {#after},
      # which adds the hook to the start of the list.
      #
      # See {Hooks#after} for full `after` hook docs.
      #
      # This method differs from {Hooks#append_after} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once after
      # the last example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #append_after
      # @see #before
      # @see #prepend_before
      def append_after: (?untyped? scope, *untyped meta) { (?) -> untyped } -> untyped

      # Registers `block` as an `around` hook.
      #
      # See {Hooks#around} for full `around` hook docs.
      def around: (?untyped? scope, *untyped meta) { (?) -> untyped } -> untyped

      # @private
      def with_suite_hooks: () { () -> untyped } -> untyped

      # @private
      # Holds the various registered hooks. Here we use a FilterableItemRepository
      # implementation that is specifically optimized for the read/write patterns
      # of the config object.
      def hooks: () -> untyped

      # Invokes block before defining an example group
      def on_example_group_definition: () { (?) -> untyped } -> untyped

      # @api private
      # Returns an array of blocks to call before defining an example group
      def on_example_group_definition_callbacks: () -> untyped

      # @private
      def bisect_runner_class: () -> untyped

      private

      def load_file_handling_errors: (untyped method, untyped file) -> untyped

      def handle_suite_hook: (untyped scope, untyped meta) { () -> untyped } -> (nil | untyped)

      def run_suite_hooks: (untyped hook_description, untyped hooks) -> untyped

      def get_files_to_run: (untyped paths) -> untyped

      def paths_to_check: (untyped paths) -> untyped

      def pattern_might_load_specs_from_vendored_dirs?: () -> untyped

      def gather_directories: (untyped path) -> untyped

      def get_matching_files: (untyped path, untyped pattern) -> untyped

      def file_glob_from: (untyped path, untyped pattern) -> untyped

      # :nocov:
      def absolute_pattern?: (untyped pattern) -> untyped

      def windows_absolute_network_path?: (untyped pattern) -> (false | untyped)

      def extract_location: (untyped path) -> (::Array[untyped] | untyped)

      def command: () -> untyped

      def value_for: (untyped key) { () -> untyped } -> untyped

      def define_built_in_hooks: () -> untyped

      def assert_no_example_groups_defined: (untyped config_option) -> (nil | untyped)

      def output_wrapper: () -> untyped

      def output_to_tty?: (?untyped output) -> untyped

      def conditionally_disable_mocks_monkey_patching: () -> (nil | untyped)

      def conditionally_disable_expectations_monkey_patching: () -> (nil | untyped)

      def rspec_mocks_loaded?: () -> untyped

      def rspec_expectations_loaded?: () -> untyped

      def update_pattern_attr: (untyped name, untyped value) -> untyped

      def clear_values_derived_from_example_status_persistence_file_path: () -> untyped

      def configure_group_with: (untyped group, untyped module_list, untyped application_method) -> untyped

      def add_hook_to_existing_matching_groups: (untyped meta, untyped scope) { (?) -> untyped } -> untyped

      def on_existing_matching_groups: (untyped meta) { (untyped) -> untyped } -> untyped

      def metadata_applies_to_group?: (untyped meta, untyped group) -> untyped

      def safe_prepend: (untyped mod, untyped host) -> (untyped | nil)

      def safe_include: (untyped mod, untyped host) -> (untyped | nil)

      def safe_extend: (untyped mod, untyped host) -> (untyped | nil)

      def define_mixed_in_module: (untyped mod, untyped filters, untyped mod_list, untyped config_method) { (?) -> untyped } -> untyped
    end
  end
end
